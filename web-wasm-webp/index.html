<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebP Encode/Decode Test</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .container {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .upload-area {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.3s, background-color 0.3s;
    }
    .upload-area:hover {
      border-color: #666;
      background-color: #fafafa;
    }
    .upload-area.dragover {
      border-color: #2196F3;
      background-color: #e3f2fd;
    }
    input[type="file"] {
      display: none;
    }
    .controls {
      display: flex;
      gap: 20px;
      margin-top: 15px;
      flex-wrap: wrap;
      align-items: center;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .control-group label {
      font-size: 14px;
      color: #666;
    }
    .control-group input[type="range"] {
      width: 150px;
    }
    .control-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    .quality-value {
      font-weight: bold;
      min-width: 30px;
    }
    .images-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .image-box {
      text-align: center;
    }
    .image-box h3 {
      margin-bottom: 10px;
      color: #666;
    }
    .image-box canvas, .image-box img {
      max-width: 100%;
      height: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .info {
      margin-top: 10px;
      font-size: 12px;
      color: #666;
    }
    .status {
      padding: 15px;
      border-radius: 4px;
      margin-top: 20px;
      display: none;
    }
    .status.loading {
      display: block;
      background: #fff3cd;
      border: 1px solid #ffc107;
      color: #856404;
    }
    .status.success {
      display: block;
      background: #d4edda;
      border: 1px solid #28a745;
      color: #155724;
    }
    .status.error {
      display: block;
      background: #f8d7da;
      border: 1px solid #dc3545;
      color: #721c24;
    }
    .comparison {
      margin-top: 20px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    .comparison h3 {
      margin-top: 0;
    }
    .comparison-result {
      font-size: 18px;
      font-weight: bold;
    }
    .comparison-result.match {
      color: #28a745;
    }
    .comparison-result.mismatch {
      color: #dc3545;
    }
    .comparison-result.lossy {
      color: #ffc107;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }
    .stat {
      background: white;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }
    .stat-label {
      font-size: 12px;
      color: #666;
    }
    .stat-value {
      font-size: 18px;
      font-weight: bold;
      color: #333;
    }
    #initStatus {
      text-align: center;
      padding: 10px;
      margin-bottom: 20px;
    }
    .download-btn {
      margin-top: 10px;
      padding: 8px 16px;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .download-btn:hover {
      background: #1976D2;
    }
  </style>
</head>
<body>
  <h1>WebP Encode/Decode Test</h1>

  <div id="initStatus">Initializing WASM modules...</div>

  <div class="container">
    <div class="upload-area" id="uploadArea">
      <p>Drop an image here (PNG, JPEG, WebP) or click to upload</p>
      <input type="file" id="fileInput" accept="image/*">
    </div>

    <div class="controls">
      <div class="control-group">
        <label for="quality">Quality:</label>
        <input type="range" id="quality" min="0" max="100" value="80">
        <span class="quality-value" id="qualityValue">80</span>
      </div>
      <div class="control-group">
        <label for="lossless">
          <input type="checkbox" id="lossless">
          Lossless
        </label>
      </div>
    </div>

    <div class="status" id="status"></div>

    <div class="images-container" id="imagesContainer" style="display: none;">
      <div class="image-box">
        <h3>Original Image</h3>
        <canvas id="originalCanvas"></canvas>
        <div class="info" id="originalInfo"></div>
      </div>

      <div class="image-box">
        <h3>WebP Encoded/Decoded</h3>
        <canvas id="reEncodedCanvas"></canvas>
        <div class="info" id="reEncodedInfo"></div>
        <button class="download-btn" id="downloadBtn" style="display: none;">Download WebP</button>
      </div>
    </div>

    <div class="comparison" id="comparison" style="display: none;">
      <h3>Comparison Results</h3>
      <div class="comparison-result" id="comparisonResult"></div>
      <div class="stats" id="stats"></div>
    </div>
  </div>

  <script type="module">
    import { init, encode, decode, DEFAULT_ENCODE_OPTS } from './webp.js';

    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const status = document.getElementById('status');
    const imagesContainer = document.getElementById('imagesContainer');
    const originalCanvas = document.getElementById('originalCanvas');
    const reEncodedCanvas = document.getElementById('reEncodedCanvas');
    const originalInfo = document.getElementById('originalInfo');
    const reEncodedInfo = document.getElementById('reEncodedInfo');
    const comparison = document.getElementById('comparison');
    const comparisonResult = document.getElementById('comparisonResult');
    const stats = document.getElementById('stats');
    const initStatus = document.getElementById('initStatus');
    const qualitySlider = document.getElementById('quality');
    const qualityValue = document.getElementById('qualityValue');
    const losslessCheckbox = document.getElementById('lossless');
    const downloadBtn = document.getElementById('downloadBtn');

    let wasmReady = false;
    let lastWebpData = null;

    // Quality slider
    qualitySlider.addEventListener('input', () => {
      qualityValue.textContent = qualitySlider.value;
    });

    // Initialize WASM module
    async function initWasm() {
      try {
        await init();
        wasmReady = true;
        initStatus.textContent = 'WASM modules ready!';
        initStatus.style.color = '#28a745';
        uploadArea.style.pointerEvents = 'auto';
      } catch (err) {
        initStatus.textContent = 'Failed to initialize WASM: ' + err.message;
        initStatus.style.color = '#dc3545';
        console.error('WASM init error:', err);
      }
    }

    initWasm();

    // Set up event listeners
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        processFile(file);
      } else {
        showStatus('Please drop an image file', 'error');
      }
    });
    fileInput.addEventListener('change', (e) => {
      if (e.target.files[0]) {
        processFile(e.target.files[0]);
      }
    });

    downloadBtn.addEventListener('click', () => {
      if (lastWebpData) {
        const blob = new Blob([lastWebpData], { type: 'image/webp' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'encoded.webp';
        a.click();
        URL.revokeObjectURL(url);
      }
    });

    function showStatus(message, type) {
      status.textContent = message;
      status.className = 'status ' + type;
    }

    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }

    async function processFile(file) {
      if (!wasmReady) {
        showStatus('WASM modules not ready yet', 'error');
        return;
      }

      showStatus('Processing...', 'loading');

      try {
        // Load image using canvas
        const img = await loadImage(file);
        const { width, height } = img;

        // Draw original to canvas to get ImageData
        originalCanvas.width = width;
        originalCanvas.height = height;
        const originalCtx = originalCanvas.getContext('2d');
        originalCtx.drawImage(img, 0, 0);
        const originalImageData = originalCtx.getImageData(0, 0, width, height);

        originalInfo.innerHTML = `
          Size: ${width} x ${height}<br>
          File Type: ${file.type}<br>
          File Size: ${formatBytes(file.size)}
        `;

        // Encode to WebP
        const quality = parseInt(qualitySlider.value);
        const lossless = losslessCheckbox.checked ? 1 : 0;

        const encodeStart = performance.now();
        const webpData = encode(originalImageData, { quality, lossless });
        const encodeTime = performance.now() - encodeStart;

        lastWebpData = webpData;

        // Decode WebP back
        const decodeStart = performance.now();
        const decodedImageData = decode(webpData);
        const decodeTime = performance.now() - decodeStart;

        // Display decoded image
        reEncodedCanvas.width = decodedImageData.width;
        reEncodedCanvas.height = decodedImageData.height;
        const reEncodedCtx = reEncodedCanvas.getContext('2d');

        // Create proper ImageData from decoded result
        const displayImageData = new ImageData(
          new Uint8ClampedArray(decodedImageData.data),
          decodedImageData.width,
          decodedImageData.height
        );
        reEncodedCtx.putImageData(displayImageData, 0, 0);

        reEncodedInfo.innerHTML = `
          Size: ${decodedImageData.width} x ${decodedImageData.height}<br>
          WebP Size: ${formatBytes(webpData.length)}<br>
          Quality: ${quality}${lossless ? ' (Lossless)' : ''}<br>
          Encode: ${encodeTime.toFixed(2)}ms | Decode: ${decodeTime.toFixed(2)}ms
        `;

        downloadBtn.style.display = 'inline-block';

        // Compare pixel data
        const compareResult = compareImages(originalImageData, decodedImageData);

        imagesContainer.style.display = 'grid';
        comparison.style.display = 'block';

        if (compareResult.identical) {
          comparisonResult.textContent = 'Images are IDENTICAL! (Lossless)';
          comparisonResult.className = 'comparison-result match';
        } else if (lossless && compareResult.psnr > 50) {
          comparisonResult.textContent = 'Lossless encoding - minimal differences';
          comparisonResult.className = 'comparison-result match';
        } else {
          comparisonResult.textContent = `Lossy encoding - PSNR: ${compareResult.psnr.toFixed(2)} dB`;
          comparisonResult.className = 'comparison-result lossy';
        }

        const compressionRatio = ((1 - webpData.length / file.size) * 100).toFixed(1);

        stats.innerHTML = `
          <div class="stat">
            <div class="stat-label">Original Size</div>
            <div class="stat-value">${formatBytes(file.size)}</div>
          </div>
          <div class="stat">
            <div class="stat-label">WebP Size</div>
            <div class="stat-value">${formatBytes(webpData.length)}</div>
          </div>
          <div class="stat">
            <div class="stat-label">Compression</div>
            <div class="stat-value">${compressionRatio}%</div>
          </div>
          <div class="stat">
            <div class="stat-label">PSNR</div>
            <div class="stat-value">${compareResult.psnr.toFixed(2)} dB</div>
          </div>
          <div class="stat">
            <div class="stat-label">Avg Diff</div>
            <div class="stat-value">${compareResult.avgDifference.toFixed(2)}</div>
          </div>
          <div class="stat">
            <div class="stat-label">Total Time</div>
            <div class="stat-value">${(encodeTime + decodeTime).toFixed(2)}ms</div>
          </div>
        `;

        showStatus('Processing complete!', 'success');

      } catch (err) {
        showStatus('Error: ' + err.message, 'error');
        console.error('Processing error:', err);
      }
    }

    function loadImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }

    function compareImages(img1, img2) {
      const data1 = img1.data;
      const data2 = img2.data;

      if (data1.length !== data2.length) {
        return {
          identical: false,
          differentPixels: data1.length / 4,
          maxDifference: 255,
          avgDifference: 255,
          psnr: 0
        };
      }

      let differentPixels = 0;
      let maxDifference = 0;
      let totalDifference = 0;
      let mse = 0;

      for (let i = 0; i < data1.length; i += 4) {
        const diffR = Math.abs(data1[i] - data2[i]);
        const diffG = Math.abs(data1[i + 1] - data2[i + 1]);
        const diffB = Math.abs(data1[i + 2] - data2[i + 2]);
        // Skip alpha for comparison as WebP might handle it differently

        const pixelDiff = Math.max(diffR, diffG, diffB);

        if (pixelDiff > 0) {
          differentPixels++;
          maxDifference = Math.max(maxDifference, pixelDiff);
          totalDifference += pixelDiff;
        }

        mse += (diffR * diffR + diffG * diffG + diffB * diffB) / 3;
      }

      const pixelCount = data1.length / 4;
      mse /= pixelCount;

      // PSNR calculation (higher is better, Infinity means identical)
      const psnr = mse === 0 ? Infinity : 10 * Math.log10((255 * 255) / mse);
      const avgDifference = differentPixels > 0 ? totalDifference / differentPixels : 0;

      return {
        identical: differentPixels === 0,
        differentPixels,
        maxDifference,
        avgDifference,
        psnr: isFinite(psnr) ? psnr : 100
      };
    }
  </script>
</body>
</html>
